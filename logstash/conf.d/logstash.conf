input {
        beats {
         port => 5044
        }
    }

# output {
#     elasticsearch {
#     index => "logstash-%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM}"
#     hosts => [ "search-pre-prod-logs-elasticsearch-47xfsfxi6a7wjjx5mc7ukkj5zu.eu-west-1.es.amazonaws.com:443" ]
#     manage_template => true
#     ilm_enabled => false
#     ssl => true
#     }
# }
output {
    amazon_es {
        hosts => ["some.elastic.host.amazon.com"]
        region => "some-aws-region"
        index => "logstash-%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM}"
        manage_template => true
        max_bulk_bytes => "10485760"
        # ilm_enabled => false
        # ssl => true
    }
}
filter {
    mutate {
        add_field => { "client_name" => "SeaIslandSoftware" }
    }
    if "geoserver-audit" in [type] {

            grok {
                patterns_dir => ["/etc/logstash/patterns/"]
                match => { 
                    message => "%{INT:RequestId},%{IPORHOST:ServerHost},(%{WORD:Service})?,((?<ServiceVersion>[\d\.]+))?,(%{WORD:Operation})?,(%{WORD:SubOperation})?,\"((?<Layers>[-\w\s:,]+))?\",(\"%{BASE10NUM:BBox1:float},%{BASE10NUM:BBox2:float},%{BASE10NUM:BBox3:float},%{BASE10NUM:BBox4:float}\")?,\"(%{URIPATH:RequestPath})?\",\"((?<QueryString>[-?A-Za-z0-9&='<> ().,;:_/+#]+))?\",\"(%{DATA:RequestBody})?\",%{WORD:RequestMethod},\"%{TIMESTAMP_ISO8601:StartTime}\",\"%{TIMESTAMP_ISO8601:EndTime}\",(%{NUMBER:ResponseTime:int})?,\"%{IPORHOST:ClientAddress}(:)?(%{NUMBER:ClientPort})?\",%{QS:remoteUser},%{QS:UserAgent},%{NUMBER:ResponseHTTPStatus:int},%{NUMBER:ResponseLength:int},%{QS:ResponseContentType},\"(%{WORD:geowebcache-cache-result})?\",(%{QS:geowebcache-cache-miss-reason})?,\"(%{WORD:Error})?\",(%{QS:ErrorMessage})?"
                }   
                add_tag => [ "grokked"]
            }
            kv {
                source => "QueryString"
                field_split => "&"
                transform_key => "uppercase"
            }
            mutate {
                lowercase => [ "Error"]
                uppercase => [ "Service"]
                rename => [ "Service", "SERVICE"]
                convert => { "RequestId" => "integer"}
                convert => { "WIDTH" => "integer"}
                convert => { "HEIGHT" => "integer"}
                convert => { "Error" => "boolean"}
                add_tag => [ "geoserver", "audit", "geoserver-audit" ]
            }
            if ![TILED] {
                mutate { add_field => { "TILED" => "false" } }
            }
            mutate {
                convert => { "TILED" => "boolean"}
            }
            date {
                match => ["StartTime", "ISO8601"]
                target => "@timestamp"
                add_tag => ["dated"]
            }
            geoip {
                source => "ClientAddress"
                # target => "geoip"
                # add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
                # add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
            }

        }

    else if "geoserver-logs" in [type] {

        mutate {
            add_tag => [ "geoserver", "log", "geoserver-logs", "geoserver-log"]
        }
        grok {
            patterns_dir => [ "/etc/logstash/patterns/" ]
            match => {
            "message" =>[ "%{GSLOG}" ]
            }
            add_tag => ["grokked"]
        }
        if "DEBUG" in [logLevel] or "TRACE" in [logLevel] or "INFO" in [logLevel] {
            drop { }
        }

    }
}